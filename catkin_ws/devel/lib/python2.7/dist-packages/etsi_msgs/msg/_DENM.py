# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from etsi_msgs/DENM.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import etsi_msgs.msg
import std_msgs.msg

class DENM(genpy.Message):
  _md5sum = "66d74b1f24152abbfb60e3e0a2c36bfb"
  _type = "etsi_msgs/DENM"
  _has_header = True  # flag to mark the presence of a Header object
  _full_text = """Header header
ItsPduHeader its_header

ManagementContainer management

bool has_situation
SituationContainer situation

bool has_location
LocationContainer location

# TODO AlacarteContainer is missing

================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

================================================================================
MSG: etsi_msgs/ItsPduHeader
uint8 protocol_version
uint8 message_id
uint32 station_id

uint8 MESSAGE_ID_DENM = 1
uint8 MESSAGE_ID_CAM = 2

================================================================================
MSG: etsi_msgs/ManagementContainer
ActionID action_id
uint64 detection_time # ms since 2004
uint64 reference_time # ms since 2004
uint8 termination
ReferencePosition event_position
RelevanceDistance relevance_distance
RelevanceTrafficDirection relevance_traffic_direction
uint32 validity_duration # seconds
uint32 transmission_interval # milliseconds
StationType station_type

uint8 TERMINATION_CANCELLATION = 0
uint8 TERMINATION_NEGATION = 1
uint8 TERMINATION_UNAVAILABLE = 255

uint32 TRANSMISSION_INTERVAL_ONE_MILLISECOND = 1
uint32 TRANSMISSION_INTERVAL_TEN_SECONDS = 10000
uint32 TRANSMISSION_INTERVAL_UNAVAILABLE = 0

uint32 VALIDITY_DURATION_DEFAULT = 600
uint32 VALIDITY_DURATION_TIME_OF_DETECTION = 0
uint32 VALIDITY_DURATION_ONE_SECOND_AFTER_DETECTION = 1

================================================================================
MSG: etsi_msgs/ActionID
uint32 station_id
uint16 sequence_number

================================================================================
MSG: etsi_msgs/ReferencePosition
int64 latitude # 0.1 micro degree
int64 longitude # 0.1 micro degree
PositionConfidenceEllipse position_confidence
Altitude altitude

int64 LATITUDE_UNAVAILABLE = 900000001
int64 LONGITUDE_UNAVAILABLE = 1800000001

================================================================================
MSG: etsi_msgs/PositionConfidenceEllipse
uint16 semi_major_confidence # cm
uint16 semi_minor_confidence # cm
uint16 semi_major_orientation # 0.1 degree

uint16 SEMI_AXIS_LENGTH_OUT_OF_RANGE = 4094
uint16 SEMI_AXIS_LENGTH_UNAVAILABLE = 4095

================================================================================
MSG: etsi_msgs/Altitude
int32 value # 0.01 meter
uint8 confidence

int32 VALUE_REFERENCE_ELLIPSOID_SURFACE = 0
int32 VALUE_ONE_CENTIMETER = 1
int32 VALUE_UNAVAILABLE = 800001

uint8 CONFIDENCE_1CM = 0
uint8 CONFIDENCE_2CM = 1
uint8 CONFIDENCE_5CM = 2
uint8 CONFIDENCE_10CM = 3
uint8 CONFIDENCE_20CM = 4
uint8 CONFIDENCE_50CM = 5
uint8 CONFIDENCE_1M = 6
uint8 CONFIDENCE_2M = 7
uint8 CONFIDENCE_5M = 8
uint8 CONFIDENCE_10M = 9
uint8 CONFIDENCE_20M = 10
uint8 CONFIDENCE_50M = 11
uint8 CONFIDENCE_100M = 12
uint8 CONFIDENCE_200M = 13
uint8 CONFIDENCE_OUT_OF_RANGE = 14
uint8 CONFIDENCE_UNAVAILABLE = 15

================================================================================
MSG: etsi_msgs/RelevanceDistance
uint8 value

uint8 LESS_THAN_50M = 0
uint8 LESS_THAN_100M = 1
uint8 LESS_THAN_200M = 2
uint8 LESS_THAN_500M = 3
uint8 LESS_THAN_1000M = 4
uint8 LESS_THAN_5KM = 5
uint8 LESS_THAN_10KM = 6
uint8 OVER_10KM = 7
uint8 UNAVAILABLE = 255

================================================================================
MSG: etsi_msgs/RelevanceTrafficDirection
uint8 value

uint8 ALL_TRAFFIC_DIRECTIONS = 0
uint8 UPSTREAM_TRAFFIC = 1
uint8 DOWNSTREAM_TRAFFIC = 2
uint8 OPPOSITE_TRAFFIC = 3
uint8 UNAVAILABLE = 255 # extension to encode optional traffic directions

================================================================================
MSG: etsi_msgs/StationType
uint8 value

uint8 UNKNOWN = 0
uint8 PEDESTRIAN = 1
uint8 CYCLIST = 2
uint8 MOPED = 3
uint8 MOTORCYCLE = 4
uint8 PASSENGER_CAR = 5
uint8 BUS = 6
uint8 LIGHT_TRUCK = 7
uint8 HEAVY_TRUCK = 8
uint8 TRAILER = 9
uint8 SPECIAL_VEHICLE = 10
uint8 TRAM = 11
uint8 ROAD_SIDE_UNIT = 15

================================================================================
MSG: etsi_msgs/SituationContainer
InformationQuality information_quality
CauseCode event_type
bool has_linked_cause
CauseCode linked_cause
EventPoint[] event_history

================================================================================
MSG: etsi_msgs/InformationQuality
int8 value

int8 UNAVAILABLE = 0
int8 LOWEST = 1
int8 HIGHEST = 7

================================================================================
MSG: etsi_msgs/CauseCode
uint8 cause_code
uint8 sub_cause_code

uint8 RESERVED = 0
uint8 TRAFFIC_CONDITION = 1
uint8 ACCIDENT = 2
uint8 ROADWORKS = 3
uint8 ADVERSE_WEATHER_CONDITIONS_ADHESION = 4
uint8 HAZARDOUS_LOCATION_SURFACE_CONDITION = 9
uint8 HAZARDOUS_LOCATION_OBSTACLE_ON_THE_ROAD = 10
uint8 HAZARDOUS_LOCATION_ANIMAL_ON_THE_ROAD = 11
uint8 HUMAN_PRESENCE_ON_THE_ROAD = 12
uint8 WRONG_WAY_DRIVING = 14
uint8 RESCUE_AND_RECOVERY_WORK_IN_PROGRESS = 15
uint8 ADVERSE_WEATHER_CONDITIONS_EXTREME_WEATHER_CONDITION = 17
uint8 ADVERSE_WEATHER_CONDITIONS_VISIBILITY = 18
uint8 ADVERSE_WEATHER_CONDITIONS_PRECIPITATION = 19
uint8 SLOW_VEHICLE = 26
uint8 DANGEROUS_END_OF_QUEUE = 27
uint8 VEHICLE_BREAKDOWN = 91
uint8 POST_CRASH = 92
uint8 HUMAN_PROBLEM = 93
uint8 STATIONARY_VEHICLE = 94
uint8 EMERGENCY_VEHICLE_APPROACHING = 95
uint8 HAZARDOUS_LOCATION_DANGEROUS_CURVE = 96
uint8 COLLISION_RISK = 97
uint8 SIGNAL_VIOLATION = 98
uint8 DANGEROUS_SITUATION = 99

================================================================================
MSG: etsi_msgs/EventPoint
DeltaReferencePosition event_position
PathDeltaTime event_delta_time
InformationQuality information_quality

================================================================================
MSG: etsi_msgs/DeltaReferencePosition
int32 delta_latitude # 0.1 micro degree
int32 delta_longitude # 0.1 micro degree
int16 delta_altitude # centimeter

int32 ONE_MICRODEGREE_NORTH = 10
int32 ONE_MICRODEGREE_SOUTH = -10
int32 ONE_MICRODEGREE_EAST = 10
int32 ONE_MICRODEGREE_WEST = -10
int32 ONE_CENTIMETER_UP = 1
int32 ONE_CENTIMETER_DOWN = -1
int32 LATITUDE_UNAVAILABLE = 131072
int32 LONGITUDE_UNAVAILABLE = 131072
int16 ALTITUDE_UNAVAILABLE = 12800

================================================================================
MSG: etsi_msgs/PathDeltaTime
uint16 value # 10 ms

uint16 UNAVAILABLE = 0
uint16 TEN_MILLISECONDS_IN_PAST = 1

================================================================================
MSG: etsi_msgs/LocationContainer
Speed event_speed
Heading event_position_heading
PathHistory[] traces
uint8 road_type

uint8 ROAD_TYPE_URBAN_NO_STRUCTURAL_SEPARATION_TO_OPPOSITE_LANES = 0
uint8 ROAD_TYPE_URBAN_WITH_STRUCTURAL_SEPARATION_TO_OPPOSITE_LANES = 1
uint8 ROAD_TYPE_NON_URBAN_NO_STRUCTURAL_SEPARATION_TO_OPPOSITE_LANES = 2
uint8 ROAD_TYPE_NON_URBAN_WITH_STRUCTURAL_SEPARATION_TO_OPPOSITE_LANES = 3
uint8 ROAD_TYPE_UNAVAILABLE = 255

================================================================================
MSG: etsi_msgs/Speed
uint16 value # 0.01 m/s
uint8 confidence # 0.01 m/s

uint16 VALUE_STANDSTILL = 0
uint16 VALUE_ONE_CENTIMETER_PER_SECOND = 1
uint16 VALUE_UNAVAILABLE = 16383

uint8 CONFIDENCE_OUT_OF_RANGE = 126
uint8 CONFIDENCE_UNAVAILABLE = 127

================================================================================
MSG: etsi_msgs/Heading
uint16 value # 0.1 degree
uint8 confidence

uint16 VALUE_NORTH = 0
uint16 VALUE_EAST = 900
uint16 VALUE_SOUTH = 1800
uint16 VALUE_WEST = 2700
uint16 VALUE_UNAVAILABLE = 3601

uint8 CONFIDENCE_ZERO_POINT_ONE_DEGREE = 1
uint8 CONFIDENCE_ONE_DEGREE = 10
uint8 CONFIDENCE_OUT_OF_RANGE = 126
uint8 CONFIDENCE_UNAVAILABLE = 127

================================================================================
MSG: etsi_msgs/PathHistory
PathPoint[] points

================================================================================
MSG: etsi_msgs/PathPoint
DeltaReferencePosition path_position
PathDeltaTime path_delta_time
"""
  __slots__ = ['header','its_header','management','has_situation','situation','has_location','location']
  _slot_types = ['std_msgs/Header','etsi_msgs/ItsPduHeader','etsi_msgs/ManagementContainer','bool','etsi_msgs/SituationContainer','bool','etsi_msgs/LocationContainer']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,its_header,management,has_situation,situation,has_location,location

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(DENM, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.its_header is None:
        self.its_header = etsi_msgs.msg.ItsPduHeader()
      if self.management is None:
        self.management = etsi_msgs.msg.ManagementContainer()
      if self.has_situation is None:
        self.has_situation = False
      if self.situation is None:
        self.situation = etsi_msgs.msg.SituationContainer()
      if self.has_location is None:
        self.has_location = False
      if self.location is None:
        self.location = etsi_msgs.msg.LocationContainer()
    else:
      self.header = std_msgs.msg.Header()
      self.its_header = etsi_msgs.msg.ItsPduHeader()
      self.management = etsi_msgs.msg.ManagementContainer()
      self.has_situation = False
      self.situation = etsi_msgs.msg.SituationContainer()
      self.has_location = False
      self.location = etsi_msgs.msg.LocationContainer()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2B2IH2QB2q3Hi3B2I2Bb5B().pack(_x.its_header.protocol_version, _x.its_header.message_id, _x.its_header.station_id, _x.management.action_id.station_id, _x.management.action_id.sequence_number, _x.management.detection_time, _x.management.reference_time, _x.management.termination, _x.management.event_position.latitude, _x.management.event_position.longitude, _x.management.event_position.position_confidence.semi_major_confidence, _x.management.event_position.position_confidence.semi_minor_confidence, _x.management.event_position.position_confidence.semi_major_orientation, _x.management.event_position.altitude.value, _x.management.event_position.altitude.confidence, _x.management.relevance_distance.value, _x.management.relevance_traffic_direction.value, _x.management.validity_duration, _x.management.transmission_interval, _x.management.station_type.value, _x.has_situation, _x.situation.information_quality.value, _x.situation.event_type.cause_code, _x.situation.event_type.sub_cause_code, _x.situation.has_linked_cause, _x.situation.linked_cause.cause_code, _x.situation.linked_cause.sub_cause_code))
      length = len(self.situation.event_history)
      buff.write(_struct_I.pack(length))
      for val1 in self.situation.event_history:
        _v1 = val1.event_position
        _x = _v1
        buff.write(_get_struct_2ih().pack(_x.delta_latitude, _x.delta_longitude, _x.delta_altitude))
        _v2 = val1.event_delta_time
        _x = _v2.value
        buff.write(_get_struct_H().pack(_x))
        _v3 = val1.information_quality
        _x = _v3.value
        buff.write(_get_struct_b().pack(_x))
      _x = self
      buff.write(_get_struct_BHBHB().pack(_x.has_location, _x.location.event_speed.value, _x.location.event_speed.confidence, _x.location.event_position_heading.value, _x.location.event_position_heading.confidence))
      length = len(self.location.traces)
      buff.write(_struct_I.pack(length))
      for val1 in self.location.traces:
        length = len(val1.points)
        buff.write(_struct_I.pack(length))
        for val2 in val1.points:
          _v4 = val2.path_position
          _x = _v4
          buff.write(_get_struct_2ih().pack(_x.delta_latitude, _x.delta_longitude, _x.delta_altitude))
          _v5 = val2.path_delta_time
          _x = _v5.value
          buff.write(_get_struct_H().pack(_x))
      _x = self.location.road_type
      buff.write(_get_struct_B().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.its_header is None:
        self.its_header = etsi_msgs.msg.ItsPduHeader()
      if self.management is None:
        self.management = etsi_msgs.msg.ManagementContainer()
      if self.situation is None:
        self.situation = etsi_msgs.msg.SituationContainer()
      if self.location is None:
        self.location = etsi_msgs.msg.LocationContainer()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 74
      (_x.its_header.protocol_version, _x.its_header.message_id, _x.its_header.station_id, _x.management.action_id.station_id, _x.management.action_id.sequence_number, _x.management.detection_time, _x.management.reference_time, _x.management.termination, _x.management.event_position.latitude, _x.management.event_position.longitude, _x.management.event_position.position_confidence.semi_major_confidence, _x.management.event_position.position_confidence.semi_minor_confidence, _x.management.event_position.position_confidence.semi_major_orientation, _x.management.event_position.altitude.value, _x.management.event_position.altitude.confidence, _x.management.relevance_distance.value, _x.management.relevance_traffic_direction.value, _x.management.validity_duration, _x.management.transmission_interval, _x.management.station_type.value, _x.has_situation, _x.situation.information_quality.value, _x.situation.event_type.cause_code, _x.situation.event_type.sub_cause_code, _x.situation.has_linked_cause, _x.situation.linked_cause.cause_code, _x.situation.linked_cause.sub_cause_code,) = _get_struct_2B2IH2QB2q3Hi3B2I2Bb5B().unpack(str[start:end])
      self.has_situation = bool(self.has_situation)
      self.situation.has_linked_cause = bool(self.situation.has_linked_cause)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.situation.event_history = []
      for i in range(0, length):
        val1 = etsi_msgs.msg.EventPoint()
        _v6 = val1.event_position
        _x = _v6
        start = end
        end += 10
        (_x.delta_latitude, _x.delta_longitude, _x.delta_altitude,) = _get_struct_2ih().unpack(str[start:end])
        _v7 = val1.event_delta_time
        start = end
        end += 2
        (_v7.value,) = _get_struct_H().unpack(str[start:end])
        _v8 = val1.information_quality
        start = end
        end += 1
        (_v8.value,) = _get_struct_b().unpack(str[start:end])
        self.situation.event_history.append(val1)
      _x = self
      start = end
      end += 7
      (_x.has_location, _x.location.event_speed.value, _x.location.event_speed.confidence, _x.location.event_position_heading.value, _x.location.event_position_heading.confidence,) = _get_struct_BHBHB().unpack(str[start:end])
      self.has_location = bool(self.has_location)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.location.traces = []
      for i in range(0, length):
        val1 = etsi_msgs.msg.PathHistory()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.points = []
        for i in range(0, length):
          val2 = etsi_msgs.msg.PathPoint()
          _v9 = val2.path_position
          _x = _v9
          start = end
          end += 10
          (_x.delta_latitude, _x.delta_longitude, _x.delta_altitude,) = _get_struct_2ih().unpack(str[start:end])
          _v10 = val2.path_delta_time
          start = end
          end += 2
          (_v10.value,) = _get_struct_H().unpack(str[start:end])
          val1.points.append(val2)
        self.location.traces.append(val1)
      start = end
      end += 1
      (self.location.road_type,) = _get_struct_B().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2B2IH2QB2q3Hi3B2I2Bb5B().pack(_x.its_header.protocol_version, _x.its_header.message_id, _x.its_header.station_id, _x.management.action_id.station_id, _x.management.action_id.sequence_number, _x.management.detection_time, _x.management.reference_time, _x.management.termination, _x.management.event_position.latitude, _x.management.event_position.longitude, _x.management.event_position.position_confidence.semi_major_confidence, _x.management.event_position.position_confidence.semi_minor_confidence, _x.management.event_position.position_confidence.semi_major_orientation, _x.management.event_position.altitude.value, _x.management.event_position.altitude.confidence, _x.management.relevance_distance.value, _x.management.relevance_traffic_direction.value, _x.management.validity_duration, _x.management.transmission_interval, _x.management.station_type.value, _x.has_situation, _x.situation.information_quality.value, _x.situation.event_type.cause_code, _x.situation.event_type.sub_cause_code, _x.situation.has_linked_cause, _x.situation.linked_cause.cause_code, _x.situation.linked_cause.sub_cause_code))
      length = len(self.situation.event_history)
      buff.write(_struct_I.pack(length))
      for val1 in self.situation.event_history:
        _v11 = val1.event_position
        _x = _v11
        buff.write(_get_struct_2ih().pack(_x.delta_latitude, _x.delta_longitude, _x.delta_altitude))
        _v12 = val1.event_delta_time
        _x = _v12.value
        buff.write(_get_struct_H().pack(_x))
        _v13 = val1.information_quality
        _x = _v13.value
        buff.write(_get_struct_b().pack(_x))
      _x = self
      buff.write(_get_struct_BHBHB().pack(_x.has_location, _x.location.event_speed.value, _x.location.event_speed.confidence, _x.location.event_position_heading.value, _x.location.event_position_heading.confidence))
      length = len(self.location.traces)
      buff.write(_struct_I.pack(length))
      for val1 in self.location.traces:
        length = len(val1.points)
        buff.write(_struct_I.pack(length))
        for val2 in val1.points:
          _v14 = val2.path_position
          _x = _v14
          buff.write(_get_struct_2ih().pack(_x.delta_latitude, _x.delta_longitude, _x.delta_altitude))
          _v15 = val2.path_delta_time
          _x = _v15.value
          buff.write(_get_struct_H().pack(_x))
      _x = self.location.road_type
      buff.write(_get_struct_B().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.its_header is None:
        self.its_header = etsi_msgs.msg.ItsPduHeader()
      if self.management is None:
        self.management = etsi_msgs.msg.ManagementContainer()
      if self.situation is None:
        self.situation = etsi_msgs.msg.SituationContainer()
      if self.location is None:
        self.location = etsi_msgs.msg.LocationContainer()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 74
      (_x.its_header.protocol_version, _x.its_header.message_id, _x.its_header.station_id, _x.management.action_id.station_id, _x.management.action_id.sequence_number, _x.management.detection_time, _x.management.reference_time, _x.management.termination, _x.management.event_position.latitude, _x.management.event_position.longitude, _x.management.event_position.position_confidence.semi_major_confidence, _x.management.event_position.position_confidence.semi_minor_confidence, _x.management.event_position.position_confidence.semi_major_orientation, _x.management.event_position.altitude.value, _x.management.event_position.altitude.confidence, _x.management.relevance_distance.value, _x.management.relevance_traffic_direction.value, _x.management.validity_duration, _x.management.transmission_interval, _x.management.station_type.value, _x.has_situation, _x.situation.information_quality.value, _x.situation.event_type.cause_code, _x.situation.event_type.sub_cause_code, _x.situation.has_linked_cause, _x.situation.linked_cause.cause_code, _x.situation.linked_cause.sub_cause_code,) = _get_struct_2B2IH2QB2q3Hi3B2I2Bb5B().unpack(str[start:end])
      self.has_situation = bool(self.has_situation)
      self.situation.has_linked_cause = bool(self.situation.has_linked_cause)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.situation.event_history = []
      for i in range(0, length):
        val1 = etsi_msgs.msg.EventPoint()
        _v16 = val1.event_position
        _x = _v16
        start = end
        end += 10
        (_x.delta_latitude, _x.delta_longitude, _x.delta_altitude,) = _get_struct_2ih().unpack(str[start:end])
        _v17 = val1.event_delta_time
        start = end
        end += 2
        (_v17.value,) = _get_struct_H().unpack(str[start:end])
        _v18 = val1.information_quality
        start = end
        end += 1
        (_v18.value,) = _get_struct_b().unpack(str[start:end])
        self.situation.event_history.append(val1)
      _x = self
      start = end
      end += 7
      (_x.has_location, _x.location.event_speed.value, _x.location.event_speed.confidence, _x.location.event_position_heading.value, _x.location.event_position_heading.confidence,) = _get_struct_BHBHB().unpack(str[start:end])
      self.has_location = bool(self.has_location)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.location.traces = []
      for i in range(0, length):
        val1 = etsi_msgs.msg.PathHistory()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.points = []
        for i in range(0, length):
          val2 = etsi_msgs.msg.PathPoint()
          _v19 = val2.path_position
          _x = _v19
          start = end
          end += 10
          (_x.delta_latitude, _x.delta_longitude, _x.delta_altitude,) = _get_struct_2ih().unpack(str[start:end])
          _v20 = val2.path_delta_time
          start = end
          end += 2
          (_v20.value,) = _get_struct_H().unpack(str[start:end])
          val1.points.append(val2)
        self.location.traces.append(val1)
      start = end
      end += 1
      (self.location.road_type,) = _get_struct_B().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2B2IH2QB2q3Hi3B2I2Bb5B = None
def _get_struct_2B2IH2QB2q3Hi3B2I2Bb5B():
    global _struct_2B2IH2QB2q3Hi3B2I2Bb5B
    if _struct_2B2IH2QB2q3Hi3B2I2Bb5B is None:
        _struct_2B2IH2QB2q3Hi3B2I2Bb5B = struct.Struct("<2B2IH2QB2q3Hi3B2I2Bb5B")
    return _struct_2B2IH2QB2q3Hi3B2I2Bb5B
_struct_2ih = None
def _get_struct_2ih():
    global _struct_2ih
    if _struct_2ih is None:
        _struct_2ih = struct.Struct("<2ih")
    return _struct_2ih
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_B = None
def _get_struct_B():
    global _struct_B
    if _struct_B is None:
        _struct_B = struct.Struct("<B")
    return _struct_B
_struct_BHBHB = None
def _get_struct_BHBHB():
    global _struct_BHBHB
    if _struct_BHBHB is None:
        _struct_BHBHB = struct.Struct("<BHBHB")
    return _struct_BHBHB
_struct_H = None
def _get_struct_H():
    global _struct_H
    if _struct_H is None:
        _struct_H = struct.Struct("<H")
    return _struct_H
_struct_b = None
def _get_struct_b():
    global _struct_b
    if _struct_b is None:
        _struct_b = struct.Struct("<b")
    return _struct_b
